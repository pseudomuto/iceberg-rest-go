// Package iceberg provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package iceberg

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
	OAuth2Scopes     = "OAuth2.Scopes"
)

// Defines values for AssertCreateType.
const (
	AssertCreateTypeAssertCreate AssertCreateType = "assert-create"
)

// Defines values for AssertCurrentSchemaIdType.
const (
	AssertCurrentSchemaIdTypeAssertCurrentSchemaId AssertCurrentSchemaIdType = "assert-current-schema-id"
)

// Defines values for AssertDefaultSortOrderIdType.
const (
	AssertDefaultSortOrderIdTypeAssertDefaultSortOrderId AssertDefaultSortOrderIdType = "assert-default-sort-order-id"
)

// Defines values for AssertDefaultSpecIdType.
const (
	AssertDefaultSpecIdTypeAssertDefaultSpecId AssertDefaultSpecIdType = "assert-default-spec-id"
)

// Defines values for AssertLastAssignedFieldIdType.
const (
	AssertLastAssignedFieldIdTypeAssertLastAssignedFieldId AssertLastAssignedFieldIdType = "assert-last-assigned-field-id"
)

// Defines values for AssertLastAssignedPartitionIdType.
const (
	AssertLastAssignedPartitionIdTypeAssertLastAssignedPartitionId AssertLastAssignedPartitionIdType = "assert-last-assigned-partition-id"
)

// Defines values for AssertRefSnapshotIdType.
const (
	AssertRefSnapshotIdTypeAssertRefSnapshotId AssertRefSnapshotIdType = "assert-ref-snapshot-id"
)

// Defines values for AssertTableUUIDType.
const (
	AssertTableUuid AssertTableUUIDType = "assert-table-uuid"
)

// Defines values for AssertViewUUIDType.
const (
	AssertViewUuid AssertViewUUIDType = "assert-view-uuid"
)

// Defines values for ListTypeType.
const (
	List ListTypeType = "list"
)

// Defines values for MapTypeType.
const (
	Map MapTypeType = "map"
)

// Defines values for NullOrder.
const (
	NullsFirst NullOrder = "nulls-first"
	NullsLast  NullOrder = "nulls-last"
)

// Defines values for OAuthClientCredentialsRequestGrantType.
const (
	ClientCredentials OAuthClientCredentialsRequestGrantType = "client_credentials"
)

// Defines values for OAuthErrorError.
const (
	InvalidClient        OAuthErrorError = "invalid_client"
	InvalidGrant         OAuthErrorError = "invalid_grant"
	InvalidRequest       OAuthErrorError = "invalid_request"
	InvalidScope         OAuthErrorError = "invalid_scope"
	UnauthorizedClient   OAuthErrorError = "unauthorized_client"
	UnsupportedGrantType OAuthErrorError = "unsupported_grant_type"
)

// Defines values for OAuthTokenExchangeRequestGrantType.
const (
	UrnIetfParamsOauthGrantTypeTokenExchange OAuthTokenExchangeRequestGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for OAuthTokenResponseTokenType.
const (
	Bearer OAuthTokenResponseTokenType = "bearer"
	Mac    OAuthTokenResponseTokenType = "mac"
	NA     OAuthTokenResponseTokenType = "N_A"
)

// Defines values for SchemaType.
const (
	SchemaTypeStruct SchemaType = "struct"
)

// Defines values for SetSnapshotRefUpdateType.
const (
	SetSnapshotRefUpdateTypeBranch SetSnapshotRefUpdateType = "branch"
	SetSnapshotRefUpdateTypeTag    SetSnapshotRefUpdateType = "tag"
)

// Defines values for SnapshotSummaryOperation.
const (
	Append    SnapshotSummaryOperation = "append"
	Delete    SnapshotSummaryOperation = "delete"
	Overwrite SnapshotSummaryOperation = "overwrite"
	Replace   SnapshotSummaryOperation = "replace"
)

// Defines values for SnapshotReferenceType.
const (
	SnapshotReferenceTypeBranch SnapshotReferenceType = "branch"
	SnapshotReferenceTypeTag    SnapshotReferenceType = "tag"
)

// Defines values for SortDirection.
const (
	Asc  SortDirection = "asc"
	Desc SortDirection = "desc"
)

// Defines values for StructTypeType.
const (
	StructTypeTypeStruct StructTypeType = "struct"
)

// Defines values for TokenType.
const (
	UrnIetfParamsOauthTokenTypeAccessToken  TokenType = "urn:ietf:params:oauth:token-type:access_token"
	UrnIetfParamsOauthTokenTypeIdToken      TokenType = "urn:ietf:params:oauth:token-type:id_token"
	UrnIetfParamsOauthTokenTypeJwt          TokenType = "urn:ietf:params:oauth:token-type:jwt"
	UrnIetfParamsOauthTokenTypeRefreshToken TokenType = "urn:ietf:params:oauth:token-type:refresh_token"
	UrnIetfParamsOauthTokenTypeSaml1        TokenType = "urn:ietf:params:oauth:token-type:saml1"
	UrnIetfParamsOauthTokenTypeSaml2        TokenType = "urn:ietf:params:oauth:token-type:saml2"
)

// Defines values for TransformTermType.
const (
	TransformTermTypeTransform TransformTermType = "transform"
)

// Defines values for DataAccess.
const (
	DataAccessRemoteSigning     DataAccess = "remote-signing"
	DataAccessVendedCredentials DataAccess = "vended-credentials"
)

// Defines values for CreateTableParamsXIcebergAccessDelegation.
const (
	CreateTableParamsXIcebergAccessDelegationRemoteSigning     CreateTableParamsXIcebergAccessDelegation = "remote-signing"
	CreateTableParamsXIcebergAccessDelegationVendedCredentials CreateTableParamsXIcebergAccessDelegation = "vended-credentials"
)

// Defines values for LoadTableParamsSnapshots.
const (
	All  LoadTableParamsSnapshots = "all"
	Refs LoadTableParamsSnapshots = "refs"
)

// Defines values for LoadTableParamsXIcebergAccessDelegation.
const (
	RemoteSigning     LoadTableParamsXIcebergAccessDelegation = "remote-signing"
	VendedCredentials LoadTableParamsXIcebergAccessDelegation = "vended-credentials"
)

// AddPartitionSpecUpdate defines model for AddPartitionSpecUpdate.
type AddPartitionSpecUpdate = BaseUpdate

// AddSchemaUpdate defines model for AddSchemaUpdate.
type AddSchemaUpdate = BaseUpdate

// AddSnapshotUpdate defines model for AddSnapshotUpdate.
type AddSnapshotUpdate = BaseUpdate

// AddSortOrderUpdate defines model for AddSortOrderUpdate.
type AddSortOrderUpdate = BaseUpdate

// AddViewVersionUpdate defines model for AddViewVersionUpdate.
type AddViewVersionUpdate = BaseUpdate

// AndOrExpression defines model for AndOrExpression.
type AndOrExpression struct {
	Left  Expression     `json:"left"`
	Right Expression     `json:"right"`
	Type  ExpressionType `json:"type"`
}

// AssertCreate The table must not already exist; used for create transactions
type AssertCreate struct {
	Type AssertCreateType `json:"type"`
}

// AssertCreateType defines model for AssertCreate.Type.
type AssertCreateType string

// AssertCurrentSchemaId The table's current schema id must match the requirement's `current-schema-id`
type AssertCurrentSchemaId struct {
	CurrentSchemaId int                       `json:"current-schema-id"`
	Type            AssertCurrentSchemaIdType `json:"type"`
}

// AssertCurrentSchemaIdType defines model for AssertCurrentSchemaId.Type.
type AssertCurrentSchemaIdType string

// AssertDefaultSortOrderId The table's default sort order id must match the requirement's `default-sort-order-id`
type AssertDefaultSortOrderId struct {
	DefaultSortOrderId int                          `json:"default-sort-order-id"`
	Type               AssertDefaultSortOrderIdType `json:"type"`
}

// AssertDefaultSortOrderIdType defines model for AssertDefaultSortOrderId.Type.
type AssertDefaultSortOrderIdType string

// AssertDefaultSpecId The table's default spec id must match the requirement's `default-spec-id`
type AssertDefaultSpecId struct {
	DefaultSpecId int                     `json:"default-spec-id"`
	Type          AssertDefaultSpecIdType `json:"type"`
}

// AssertDefaultSpecIdType defines model for AssertDefaultSpecId.Type.
type AssertDefaultSpecIdType string

// AssertLastAssignedFieldId The table's last assigned column id must match the requirement's `last-assigned-field-id`
type AssertLastAssignedFieldId struct {
	LastAssignedFieldId int                           `json:"last-assigned-field-id"`
	Type                AssertLastAssignedFieldIdType `json:"type"`
}

// AssertLastAssignedFieldIdType defines model for AssertLastAssignedFieldId.Type.
type AssertLastAssignedFieldIdType string

// AssertLastAssignedPartitionId The table's last assigned partition id must match the requirement's `last-assigned-partition-id`
type AssertLastAssignedPartitionId struct {
	LastAssignedPartitionId int                               `json:"last-assigned-partition-id"`
	Type                    AssertLastAssignedPartitionIdType `json:"type"`
}

// AssertLastAssignedPartitionIdType defines model for AssertLastAssignedPartitionId.Type.
type AssertLastAssignedPartitionIdType string

// AssertRefSnapshotId The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`; if `snapshot-id` is `null` or missing, the ref must not already exist
type AssertRefSnapshotId struct {
	Ref        string                  `json:"ref"`
	SnapshotId int64                   `json:"snapshot-id"`
	Type       AssertRefSnapshotIdType `json:"type"`
}

// AssertRefSnapshotIdType defines model for AssertRefSnapshotId.Type.
type AssertRefSnapshotIdType string

// AssertTableUUID The table UUID must match the requirement's `uuid`
type AssertTableUUID struct {
	Type AssertTableUUIDType `json:"type"`
	Uuid string              `json:"uuid"`
}

// AssertTableUUIDType defines model for AssertTableUUID.Type.
type AssertTableUUIDType string

// AssertViewUUID The view UUID must match the requirement's `uuid`
type AssertViewUUID struct {
	Type AssertViewUUIDType `json:"type"`
	Uuid string             `json:"uuid"`
}

// AssertViewUUIDType defines model for AssertViewUUID.Type.
type AssertViewUUIDType string

// AssignUUIDUpdate defines model for AssignUUIDUpdate.
type AssignUUIDUpdate = BaseUpdate

// BaseUpdate defines model for BaseUpdate.
type BaseUpdate struct {
	Action string `json:"action"`
}

// BlobMetadata defines model for BlobMetadata.
type BlobMetadata struct {
	Fields         []int              `json:"fields"`
	Properties     *map[string]string `json:"properties,omitempty"`
	SequenceNumber int64              `json:"sequence-number"`
	SnapshotId     int64              `json:"snapshot-id"`
	Type           string             `json:"type"`
}

// CatalogConfig Server-provided configuration for the catalog.
type CatalogConfig struct {
	// Defaults Properties that should be used as default configuration; applied before client configuration.
	Defaults map[string]string `json:"defaults"`

	// Overrides Properties that should be used to override client configuration; applied after defaults and client configuration.
	Overrides map[string]string `json:"overrides"`
}

// CommitReport defines model for CommitReport.
type CommitReport struct {
	Metadata       *map[string]string `json:"metadata,omitempty"`
	Metrics        Metrics            `json:"metrics"`
	Operation      string             `json:"operation"`
	SequenceNumber int64              `json:"sequence-number"`
	SnapshotId     int64              `json:"snapshot-id"`
	TableName      string             `json:"table-name"`
}

// CommitTableRequest defines model for CommitTableRequest.
type CommitTableRequest struct {
	Identifier   *TableIdentifier   `json:"identifier,omitempty"`
	Requirements []TableRequirement `json:"requirements"`
	Updates      []TableUpdate      `json:"updates"`
}

// CommitTableResponse defines model for CommitTableResponse.
type CommitTableResponse struct {
	Metadata         TableMetadata `json:"metadata"`
	MetadataLocation string        `json:"metadata-location"`
}

// CommitTransactionRequest defines model for CommitTransactionRequest.
type CommitTransactionRequest struct {
	TableChanges []CommitTableRequest `json:"table-changes"`
}

// CommitViewRequest defines model for CommitViewRequest.
type CommitViewRequest struct {
	Identifier   *TableIdentifier   `json:"identifier,omitempty"`
	Requirements *[]ViewRequirement `json:"requirements,omitempty"`
	Updates      []ViewUpdate       `json:"updates"`
}

// CounterResult defines model for CounterResult.
type CounterResult struct {
	Unit  string `json:"unit"`
	Value int64  `json:"value"`
}

// CreateNamespaceRequest defines model for CreateNamespaceRequest.
type CreateNamespaceRequest struct {
	// Namespaces Reference to one or more levels of a namespace
	Namespaces Namespaces `json:"namespace"`

	// Properties Configured string to string map of properties for the namespace
	Properties *map[string]string `json:"properties,omitempty"`
}

// CreateNamespaceResponse defines model for CreateNamespaceResponse.
type CreateNamespaceResponse struct {
	// Namespaces Reference to one or more levels of a namespace
	Namespaces Namespaces `json:"namespace"`

	// Properties Properties stored on the namespace, if supported by the server.
	Properties *map[string]string `json:"properties,omitempty"`
}

// CreateTableRequest defines model for CreateTableRequest.
type CreateTableRequest struct {
	Location      *string            `json:"location,omitempty"`
	Name          string             `json:"name"`
	PartitionSpec *PartitionSpec     `json:"partition-spec,omitempty"`
	Properties    *map[string]string `json:"properties,omitempty"`
	Schema        Schema             `json:"schema"`
	StageCreate   *bool              `json:"stage-create,omitempty"`
	WriteOrder    *SortOrder         `json:"write-order,omitempty"`
}

// CreateViewRequest defines model for CreateViewRequest.
type CreateViewRequest struct {
	Location    *string           `json:"location,omitempty"`
	Name        string            `json:"name"`
	Properties  map[string]string `json:"properties"`
	Schema      Schema            `json:"schema"`
	ViewVersion ViewVersion       `json:"view-version"`
}

// ErrorModel JSON error payload returned in a response with further details on the error
type ErrorModel struct {
	// Code HTTP response code
	Code int `json:"code"`

	// Message Human-readable error message
	Message string    `json:"message"`
	Stack   *[]string `json:"stack,omitempty"`

	// Type Internal type definition of the error
	Type string `json:"type"`
}

// Expression defines model for Expression.
type Expression struct {
	union json.RawMessage
}

// ExpressionType defines model for ExpressionType.
type ExpressionType = string

// GetNamespaceResponse defines model for GetNamespaceResponse.
type GetNamespaceResponse struct {
	// Namespaces Reference to one or more levels of a namespace
	Namespaces Namespaces `json:"namespace"`

	// Properties Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.
	Properties *map[string]string `json:"properties"`
}

// IcebergErrorResponse JSON wrapper for all error responses (non-2xx)
type IcebergErrorResponse struct {
	// Error JSON error payload returned in a response with further details on the error
	Error ErrorModel `json:"error"`
}

// ListNamespacesResponse defines model for ListNamespacesResponse.
type ListNamespacesResponse struct {
	Namespaces *[]Namespaces `json:"namespaces,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListTablesResponse defines model for ListTablesResponse.
type ListTablesResponse struct {
	Identifiers *[]TableIdentifier `json:"identifiers,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListType defines model for ListType.
type ListType struct {
	Element         Type         `json:"element"`
	ElementId       int          `json:"element-id"`
	ElementRequired bool         `json:"element-required"`
	Type            ListTypeType `json:"type"`
}

// ListTypeType defines model for ListType.Type.
type ListTypeType string

// LiteralExpression defines model for LiteralExpression.
type LiteralExpression struct {
	Term  Term                   `json:"term"`
	Type  ExpressionType         `json:"type"`
	Value map[string]interface{} `json:"value"`
}

// LoadTableResult Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
type LoadTableResult struct {
	Config   *map[string]string `json:"config,omitempty"`
	Metadata TableMetadata      `json:"metadata"`

	// MetadataLocation May be null if the table is staged as part of a transaction
	MetadataLocation *string `json:"metadata-location,omitempty"`
}

// LoadViewResult Result used when a view is successfully loaded.
//
// The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
// Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
//
// The `config` map returns view-specific configuration for the view's resources.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
type LoadViewResult struct {
	Config           *map[string]string `json:"config,omitempty"`
	Metadata         ViewMetadata       `json:"metadata"`
	MetadataLocation string             `json:"metadata-location"`
}

// MapType defines model for MapType.
type MapType struct {
	Key           Type        `json:"key"`
	KeyId         int         `json:"key-id"`
	Type          MapTypeType `json:"type"`
	Value         Type        `json:"value"`
	ValueId       int         `json:"value-id"`
	ValueRequired bool        `json:"value-required"`
}

// MapTypeType defines model for MapType.Type.
type MapTypeType string

// MetadataLog defines model for MetadataLog.
type MetadataLog = []struct {
	MetadataFile string `json:"metadata-file"`
	TimestampMs  int64  `json:"timestamp-ms"`
}

// MetricResult defines model for MetricResult.
type MetricResult struct {
	union json.RawMessage
}

// Metrics defines model for Metrics.
type Metrics map[string]MetricResult

// Namespaces Reference to one or more levels of a namespace
type Namespaces = []string

// NotExpression defines model for NotExpression.
type NotExpression struct {
	Child Expression     `json:"child"`
	Type  ExpressionType `json:"type"`
}

// NullOrder defines model for NullOrder.
type NullOrder string

// OAuthClientCredentialsRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
//
// # OAuth2 client credentials request
//
// See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
type OAuthClientCredentialsRequest struct {
	// ClientId Client ID
	//
	// This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret
	//
	// This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
	ClientSecret string                                 `json:"client_secret"`
	GrantType    OAuthClientCredentialsRequestGrantType `json:"grant_type"`
	Scope        *string                                `json:"scope,omitempty"`
}

// OAuthClientCredentialsRequestGrantType defines model for OAuthClientCredentialsRequest.GrantType.
type OAuthClientCredentialsRequestGrantType string

// OAuthError The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthError struct {
	Error            OAuthErrorError `json:"error"`
	ErrorDescription *string         `json:"error_description,omitempty"`
	ErrorUri         *string         `json:"error_uri,omitempty"`
}

// OAuthErrorError defines model for OAuthError.Error.
type OAuthErrorError string

// OAuthTokenExchangeRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
//
// # OAuth2 token exchange request
//
// See https://datatracker.ietf.org/doc/html/rfc8693
type OAuthTokenExchangeRequest struct {
	// ActorToken Actor token for token exchange request
	ActorToken *string `json:"actor_token,omitempty"`

	// ActorTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	ActorTokenType *TokenType                         `json:"actor_token_type,omitempty"`
	GrantType      OAuthTokenExchangeRequestGrantType `json:"grant_type"`

	// RequestedTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	RequestedTokenType *TokenType `json:"requested_token_type,omitempty"`
	Scope              *string    `json:"scope,omitempty"`

	// SubjectToken Subject token for token exchange request
	SubjectToken string `json:"subject_token"`

	// SubjectTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	SubjectTokenType TokenType `json:"subject_token_type"`
}

// OAuthTokenExchangeRequestGrantType defines model for OAuthTokenExchangeRequest.GrantType.
type OAuthTokenExchangeRequestGrantType string

// OAuthTokenRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthTokenRequest struct {
	union json.RawMessage
}

// OAuthTokenResponse The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthTokenResponse struct {
	// AccessToken The access token, for client credentials or token exchange
	AccessToken string `json:"access_token"`

	// ExpiresIn Lifetime of the access token in seconds for client credentials or token exchange
	ExpiresIn *int `json:"expires_in,omitempty"`

	// IssuedTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	IssuedTokenType *TokenType `json:"issued_token_type,omitempty"`

	// RefreshToken Refresh token for client credentials or token exchange
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope Authorization scope for client credentials or token exchange
	Scope *string `json:"scope,omitempty"`

	// TokenType Access token type for client credentials or token exchange
	//
	// See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
	TokenType OAuthTokenResponseTokenType `json:"token_type"`
}

// OAuthTokenResponseTokenType Access token type for client credentials or token exchange
//
// See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
type OAuthTokenResponseTokenType string

// PageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
type PageToken = string

// PartitionField defines model for PartitionField.
type PartitionField struct {
	FieldId   *int      `json:"field-id,omitempty"`
	Name      string    `json:"name"`
	SourceId  int       `json:"source-id"`
	Transform Transform `json:"transform"`
}

// PartitionSpec defines model for PartitionSpec.
type PartitionSpec struct {
	Fields []PartitionField `json:"fields"`
	SpecId *int             `json:"spec-id,omitempty"`
}

// PartitionStatisticsFile defines model for PartitionStatisticsFile.
type PartitionStatisticsFile struct {
	FileSizeInBytes int64  `json:"file-size-in-bytes"`
	SnapshotId      int64  `json:"snapshot-id"`
	StatisticsPath  string `json:"statistics-path"`
}

// PrimitiveType defines model for PrimitiveType.
type PrimitiveType = string

// Reference defines model for Reference.
type Reference = string

// RegisterTableRequest defines model for RegisterTableRequest.
type RegisterTableRequest struct {
	MetadataLocation string `json:"metadata-location"`
	Name             string `json:"name"`
}

// RemovePropertiesUpdate defines model for RemovePropertiesUpdate.
type RemovePropertiesUpdate = BaseUpdate

// RemoveSnapshotRefUpdate defines model for RemoveSnapshotRefUpdate.
type RemoveSnapshotRefUpdate = BaseUpdate

// RemoveSnapshotsUpdate defines model for RemoveSnapshotsUpdate.
type RemoveSnapshotsUpdate = BaseUpdate

// RemoveStatisticsUpdate defines model for RemoveStatisticsUpdate.
type RemoveStatisticsUpdate = BaseUpdate

// RenameTableRequest defines model for RenameTableRequest.
type RenameTableRequest struct {
	Destination TableIdentifier `json:"destination"`
	Source      TableIdentifier `json:"source"`
}

// ReportMetricsRequest defines model for ReportMetricsRequest.
type ReportMetricsRequest struct {
	ReportType string `json:"report-type"`
	union      json.RawMessage
}

// SQLViewRepresentation defines model for SQLViewRepresentation.
type SQLViewRepresentation struct {
	Dialect string `json:"dialect"`
	Sql     string `json:"sql"`
	Type    string `json:"type"`
}

// ScanReport defines model for ScanReport.
type ScanReport struct {
	Filter              Expression         `json:"filter"`
	Metadata            *map[string]string `json:"metadata,omitempty"`
	Metrics             Metrics            `json:"metrics"`
	ProjectedFieldIds   []int              `json:"projected-field-ids"`
	ProjectedFieldNames []string           `json:"projected-field-names"`
	SchemaId            int                `json:"schema-id"`
	SnapshotId          int64              `json:"snapshot-id"`
	TableName           string             `json:"table-name"`
}

// Schema defines model for Schema.
type Schema struct {
	Fields             []StructField `json:"fields"`
	IdentifierFieldIds *[]int        `json:"identifier-field-ids,omitempty"`
	SchemaId           *int          `json:"schema-id,omitempty"`
	Type               SchemaType    `json:"type"`
}

// SchemaType defines model for Schema.Type.
type SchemaType string

// SetCurrentSchemaUpdate defines model for SetCurrentSchemaUpdate.
type SetCurrentSchemaUpdate = BaseUpdate

// SetCurrentViewVersionUpdate defines model for SetCurrentViewVersionUpdate.
type SetCurrentViewVersionUpdate = BaseUpdate

// SetDefaultSortOrderUpdate defines model for SetDefaultSortOrderUpdate.
type SetDefaultSortOrderUpdate = BaseUpdate

// SetDefaultSpecUpdate defines model for SetDefaultSpecUpdate.
type SetDefaultSpecUpdate = BaseUpdate

// SetExpression defines model for SetExpression.
type SetExpression struct {
	Term   Term                     `json:"term"`
	Type   ExpressionType           `json:"type"`
	Values []map[string]interface{} `json:"values"`
}

// SetLocationUpdate defines model for SetLocationUpdate.
type SetLocationUpdate = BaseUpdate

// SetPropertiesUpdate defines model for SetPropertiesUpdate.
type SetPropertiesUpdate = BaseUpdate

// SetSnapshotRefUpdate defines model for SetSnapshotRefUpdate.
type SetSnapshotRefUpdate struct {
	Action             string                   `json:"action"`
	MaxRefAgeMs        *int64                   `json:"max-ref-age-ms,omitempty"`
	MaxSnapshotAgeMs   *int64                   `json:"max-snapshot-age-ms,omitempty"`
	MinSnapshotsToKeep *int                     `json:"min-snapshots-to-keep,omitempty"`
	SnapshotId         int64                    `json:"snapshot-id"`
	Type               SetSnapshotRefUpdateType `json:"type"`
}

// SetSnapshotRefUpdateType defines model for SetSnapshotRefUpdate.Type.
type SetSnapshotRefUpdateType string

// SetStatisticsUpdate defines model for SetStatisticsUpdate.
type SetStatisticsUpdate = BaseUpdate

// Snapshot defines model for Snapshot.
type Snapshot struct {
	// ManifestList Location of the snapshot's manifest list file
	ManifestList     string           `json:"manifest-list"`
	ParentSnapshotId *int64           `json:"parent-snapshot-id,omitempty"`
	SchemaId         *int             `json:"schema-id,omitempty"`
	SequenceNumber   *int64           `json:"sequence-number,omitempty"`
	SnapshotId       int64            `json:"snapshot-id"`
	Summary          Snapshot_Summary `json:"summary"`
	TimestampMs      int64            `json:"timestamp-ms"`
}

// SnapshotSummaryOperation defines model for Snapshot.Summary.Operation.
type SnapshotSummaryOperation string

// Snapshot_Summary defines model for Snapshot.Summary.
type Snapshot_Summary struct {
	Operation            SnapshotSummaryOperation `json:"operation"`
	AdditionalProperties map[string]string        `json:"-"`
}

// SnapshotLog defines model for SnapshotLog.
type SnapshotLog = []struct {
	SnapshotId  int64 `json:"snapshot-id"`
	TimestampMs int64 `json:"timestamp-ms"`
}

// SnapshotReference defines model for SnapshotReference.
type SnapshotReference struct {
	MaxRefAgeMs        *int64                `json:"max-ref-age-ms,omitempty"`
	MaxSnapshotAgeMs   *int64                `json:"max-snapshot-age-ms,omitempty"`
	MinSnapshotsToKeep *int                  `json:"min-snapshots-to-keep,omitempty"`
	SnapshotId         int64                 `json:"snapshot-id"`
	Type               SnapshotReferenceType `json:"type"`
}

// SnapshotReferenceType defines model for SnapshotReference.Type.
type SnapshotReferenceType string

// SnapshotReferences defines model for SnapshotReferences.
type SnapshotReferences map[string]SnapshotReference

// SortDirection defines model for SortDirection.
type SortDirection string

// SortField defines model for SortField.
type SortField struct {
	Direction SortDirection `json:"direction"`
	NullOrder NullOrder     `json:"null-order"`
	SourceId  int           `json:"source-id"`
	Transform Transform     `json:"transform"`
}

// SortOrder defines model for SortOrder.
type SortOrder struct {
	Fields  []SortField `json:"fields"`
	OrderId *int        `json:"order-id,omitempty"`
}

// StatisticsFile defines model for StatisticsFile.
type StatisticsFile struct {
	BlobMetadata          []BlobMetadata `json:"blob-metadata"`
	FileFooterSizeInBytes int64          `json:"file-footer-size-in-bytes"`
	FileSizeInBytes       int64          `json:"file-size-in-bytes"`
	SnapshotId            int64          `json:"snapshot-id"`
	StatisticsPath        string         `json:"statistics-path"`
}

// StructField defines model for StructField.
type StructField struct {
	Doc      *string `json:"doc,omitempty"`
	Id       int     `json:"id"`
	Name     string  `json:"name"`
	Required bool    `json:"required"`
	Type     Type    `json:"type"`
}

// StructType defines model for StructType.
type StructType struct {
	Fields []StructField  `json:"fields"`
	Type   StructTypeType `json:"type"`
}

// StructTypeType defines model for StructType.Type.
type StructTypeType string

// TableIdentifier defines model for TableIdentifier.
type TableIdentifier struct {
	Name string `json:"name"`

	// Namespaces Reference to one or more levels of a namespace
	Namespaces Namespaces `json:"namespace"`
}

// TableMetadata defines model for TableMetadata.
type TableMetadata struct {
	CurrentSchemaId     *int                       `json:"current-schema-id,omitempty"`
	CurrentSnapshotId   *int64                     `json:"current-snapshot-id,omitempty"`
	DefaultSortOrderId  *int                       `json:"default-sort-order-id,omitempty"`
	DefaultSpecId       *int                       `json:"default-spec-id,omitempty"`
	FormatVersion       int                        `json:"format-version"`
	LastColumnId        *int                       `json:"last-column-id,omitempty"`
	LastPartitionId     *int                       `json:"last-partition-id,omitempty"`
	LastSequenceNumber  *int64                     `json:"last-sequence-number,omitempty"`
	LastUpdatedMs       *int64                     `json:"last-updated-ms,omitempty"`
	Location            *string                    `json:"location,omitempty"`
	MetadataLog         *MetadataLog               `json:"metadata-log,omitempty"`
	PartitionSpecs      *[]PartitionSpec           `json:"partition-specs,omitempty"`
	PartitionStatistics *[]PartitionStatisticsFile `json:"partition-statistics,omitempty"`
	Properties          *map[string]string         `json:"properties,omitempty"`
	Refs                *SnapshotReferences        `json:"refs,omitempty"`
	Schemas             *[]Schema                  `json:"schemas,omitempty"`
	SnapshotLog         *SnapshotLog               `json:"snapshot-log,omitempty"`
	Snapshots           *[]Snapshot                `json:"snapshots,omitempty"`
	SortOrders          *[]SortOrder               `json:"sort-orders,omitempty"`
	Statistics          *[]StatisticsFile          `json:"statistics,omitempty"`
	TableUuid           string                     `json:"table-uuid"`
}

// TableRequirement defines model for TableRequirement.
type TableRequirement struct {
	union json.RawMessage
}

// TableUpdate defines model for TableUpdate.
type TableUpdate struct {
	union json.RawMessage
}

// Term defines model for Term.
type Term struct {
	union json.RawMessage
}

// TimerResult defines model for TimerResult.
type TimerResult struct {
	Count         int64  `json:"count"`
	TimeUnit      string `json:"time-unit"`
	TotalDuration int64  `json:"total-duration"`
}

// TokenType Token type identifier, from RFC 8693 Section 3
//
// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
type TokenType string

// Transform defines model for Transform.
type Transform = string

// TransformTerm defines model for TransformTerm.
type TransformTerm struct {
	Term      Reference         `json:"term"`
	Transform Transform         `json:"transform"`
	Type      TransformTermType `json:"type"`
}

// TransformTermType defines model for TransformTerm.Type.
type TransformTermType string

// Type defines model for Type.
type Type struct {
	union json.RawMessage
}

// UnaryExpression defines model for UnaryExpression.
type UnaryExpression struct {
	Term  Term                   `json:"term"`
	Type  ExpressionType         `json:"type"`
	Value map[string]interface{} `json:"value"`
}

// UpdateNamespacePropertiesRequest defines model for UpdateNamespacePropertiesRequest.
type UpdateNamespacePropertiesRequest struct {
	Removals *[]string          `json:"removals,omitempty"`
	Updates  *map[string]string `json:"updates,omitempty"`
}

// UpdateNamespacePropertiesResponse defines model for UpdateNamespacePropertiesResponse.
type UpdateNamespacePropertiesResponse struct {
	// Missing List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.
	Missing *[]string `json:"missing"`

	// Removed List of properties that were removed
	Removed []string `json:"removed"`

	// Updated List of property keys that were added or updated
	Updated []string `json:"updated"`
}

// UpgradeFormatVersionUpdate defines model for UpgradeFormatVersionUpdate.
type UpgradeFormatVersionUpdate = BaseUpdate

// ViewHistoryEntry defines model for ViewHistoryEntry.
type ViewHistoryEntry struct {
	TimestampMs int64 `json:"timestamp-ms"`
	VersionId   int   `json:"version-id"`
}

// ViewMetadata defines model for ViewMetadata.
type ViewMetadata struct {
	CurrentVersionId int                `json:"current-version-id"`
	FormatVersion    int                `json:"format-version"`
	Location         string             `json:"location"`
	Properties       *map[string]string `json:"properties,omitempty"`
	Schemas          []Schema           `json:"schemas"`
	VersionLog       []ViewHistoryEntry `json:"version-log"`
	Versions         []ViewVersion      `json:"versions"`
	ViewUuid         string             `json:"view-uuid"`
}

// ViewRepresentation defines model for ViewRepresentation.
type ViewRepresentation struct {
	union json.RawMessage
}

// ViewRequirement defines model for ViewRequirement.
type ViewRequirement struct {
	union json.RawMessage
}

// ViewUpdate defines model for ViewUpdate.
type ViewUpdate struct {
	union json.RawMessage
}

// ViewVersion defines model for ViewVersion.
type ViewVersion struct {
	DefaultCatalog *string `json:"default-catalog,omitempty"`

	// Namespaces Reference to one or more levels of a namespace
	Namespaces      Namespaces           `json:"default-namespace"`
	Representations []ViewRepresentation `json:"representations"`

	// SchemaId Schema ID to set as current, or -1 to set last added schema
	SchemaId    int               `json:"schema-id"`
	Summary     map[string]string `json:"summary"`
	TimestampMs int64             `json:"timestamp-ms"`
	VersionId   int               `json:"version-id"`
}

// DataAccess defines model for data-access.
type DataAccess string

// Namespace defines model for namespace.
type Namespace = string

// PageSize defines model for page-size.
type PageSize = int

// Table defines model for table.
type Table = string

// View defines model for view.
type View = string

// AuthenticationTimeoutResponse JSON wrapper for all error responses (non-2xx)
type AuthenticationTimeoutResponse = IcebergErrorResponse

// BadRequestErrorResponse JSON wrapper for all error responses (non-2xx)
type BadRequestErrorResponse = IcebergErrorResponse

// CreateTableResponse Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
type CreateTableResponse = LoadTableResult

// ForbiddenResponse JSON wrapper for all error responses (non-2xx)
type ForbiddenResponse = IcebergErrorResponse

// LoadTableResponse Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
type LoadTableResponse = LoadTableResult

// LoadViewResponse Result used when a view is successfully loaded.
//
// The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
// Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
//
// The `config` map returns view-specific configuration for the view's resources.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
type LoadViewResponse = LoadViewResult

// OAuthErrorResponse The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthErrorResponse = OAuthError

// ServerErrorResponse JSON wrapper for all error responses (non-2xx)
type ServerErrorResponse = IcebergErrorResponse

// ServiceUnavailableResponse JSON wrapper for all error responses (non-2xx)
type ServiceUnavailableResponse = IcebergErrorResponse

// UnauthorizedResponse JSON wrapper for all error responses (non-2xx)
type UnauthorizedResponse = IcebergErrorResponse

// UnsupportedOperationResponse JSON error payload returned in a response with further details on the error
type UnsupportedOperationResponse = ErrorModel

// GetConfigParams defines parameters for GetConfig.
type GetConfigParams struct {
	// Warehouse Warehouse location or identifier to request from the service
	Warehouse *string `form:"warehouse,omitempty" json:"warehouse,omitempty"`
}

// ListNamespacesParams defines parameters for ListNamespaces.
type ListNamespacesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Parent An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (`0x1F`) byte.
	Parent *string `form:"parent,omitempty" json:"parent,omitempty"`
}

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// XIcebergAccessDelegation Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
	//
	// Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
	//
	// The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
	XIcebergAccessDelegation *CreateTableParamsXIcebergAccessDelegation `json:"X-Iceberg-Access-Delegation,omitempty"`
}

// CreateTableParamsXIcebergAccessDelegation defines parameters for CreateTable.
type CreateTableParamsXIcebergAccessDelegation string

// DropTableParams defines parameters for DropTable.
type DropTableParams struct {
	// PurgeRequested Whether the user requested to purge the underlying table's data and metadata
	PurgeRequested *bool `form:"purgeRequested,omitempty" json:"purgeRequested,omitempty"`
}

// LoadTableParams defines parameters for LoadTable.
type LoadTableParams struct {
	// Snapshots The snapshots to return in the body of the metadata. Setting the value to `all` would return the full set of snapshots currently valid for the table. Setting the value to `refs` would load all snapshots referenced by branches or tags.
	// Default if no param is provided is `all`.
	Snapshots *LoadTableParamsSnapshots `form:"snapshots,omitempty" json:"snapshots,omitempty"`

	// XIcebergAccessDelegation Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
	//
	// Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
	//
	// The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
	XIcebergAccessDelegation *LoadTableParamsXIcebergAccessDelegation `json:"X-Iceberg-Access-Delegation,omitempty"`
}

// LoadTableParamsSnapshots defines parameters for LoadTable.
type LoadTableParamsSnapshots string

// LoadTableParamsXIcebergAccessDelegation defines parameters for LoadTable.
type LoadTableParamsXIcebergAccessDelegation string

// ListViewsParams defines parameters for ListViews.
type ListViewsParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CreateNamespaceJSONRequestBody defines body for CreateNamespace for application/json ContentType.
type CreateNamespaceJSONRequestBody = CreateNamespaceRequest

// UpdatePropertiesJSONRequestBody defines body for UpdateProperties for application/json ContentType.
type UpdatePropertiesJSONRequestBody = UpdateNamespacePropertiesRequest

// RegisterTableJSONRequestBody defines body for RegisterTable for application/json ContentType.
type RegisterTableJSONRequestBody = RegisterTableRequest

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateTableRequest

// UpdateTableJSONRequestBody defines body for UpdateTable for application/json ContentType.
type UpdateTableJSONRequestBody = CommitTableRequest

// ReportMetricsJSONRequestBody defines body for ReportMetrics for application/json ContentType.
type ReportMetricsJSONRequestBody = ReportMetricsRequest

// CreateViewJSONRequestBody defines body for CreateView for application/json ContentType.
type CreateViewJSONRequestBody = CreateViewRequest

// ReplaceViewJSONRequestBody defines body for ReplaceView for application/json ContentType.
type ReplaceViewJSONRequestBody = CommitViewRequest

// GetTokenFormdataRequestBody defines body for GetToken for application/x-www-form-urlencoded ContentType.
type GetTokenFormdataRequestBody = OAuthTokenRequest

// RenameTableJSONRequestBody defines body for RenameTable for application/json ContentType.
type RenameTableJSONRequestBody = RenameTableRequest

// CommitTransactionJSONRequestBody defines body for CommitTransaction for application/json ContentType.
type CommitTransactionJSONRequestBody = CommitTransactionRequest

// RenameViewJSONRequestBody defines body for RenameView for application/json ContentType.
type RenameViewJSONRequestBody = RenameTableRequest

// Getter for additional properties for Snapshot_Summary. Returns the specified
// element and whether it was found
func (a Snapshot_Summary) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Snapshot_Summary
func (a *Snapshot_Summary) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Snapshot_Summary to handle AdditionalProperties
func (a *Snapshot_Summary) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["operation"]; found {
		err = json.Unmarshal(raw, &a.Operation)
		if err != nil {
			return fmt.Errorf("error reading 'operation': %w", err)
		}
		delete(object, "operation")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Snapshot_Summary to handle AdditionalProperties
func (a Snapshot_Summary) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["operation"], err = json.Marshal(a.Operation)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'operation': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAndOrExpression returns the union data inside the Expression as a AndOrExpression
func (t Expression) AsAndOrExpression() (AndOrExpression, error) {
	var body AndOrExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAndOrExpression overwrites any union data inside the Expression as the provided AndOrExpression
func (t *Expression) FromAndOrExpression(v AndOrExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAndOrExpression performs a merge with any union data inside the Expression, using the provided AndOrExpression
func (t *Expression) MergeAndOrExpression(v AndOrExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotExpression returns the union data inside the Expression as a NotExpression
func (t Expression) AsNotExpression() (NotExpression, error) {
	var body NotExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotExpression overwrites any union data inside the Expression as the provided NotExpression
func (t *Expression) FromNotExpression(v NotExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotExpression performs a merge with any union data inside the Expression, using the provided NotExpression
func (t *Expression) MergeNotExpression(v NotExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetExpression returns the union data inside the Expression as a SetExpression
func (t Expression) AsSetExpression() (SetExpression, error) {
	var body SetExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetExpression overwrites any union data inside the Expression as the provided SetExpression
func (t *Expression) FromSetExpression(v SetExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetExpression performs a merge with any union data inside the Expression, using the provided SetExpression
func (t *Expression) MergeSetExpression(v SetExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLiteralExpression returns the union data inside the Expression as a LiteralExpression
func (t Expression) AsLiteralExpression() (LiteralExpression, error) {
	var body LiteralExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLiteralExpression overwrites any union data inside the Expression as the provided LiteralExpression
func (t *Expression) FromLiteralExpression(v LiteralExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLiteralExpression performs a merge with any union data inside the Expression, using the provided LiteralExpression
func (t *Expression) MergeLiteralExpression(v LiteralExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnaryExpression returns the union data inside the Expression as a UnaryExpression
func (t Expression) AsUnaryExpression() (UnaryExpression, error) {
	var body UnaryExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnaryExpression overwrites any union data inside the Expression as the provided UnaryExpression
func (t *Expression) FromUnaryExpression(v UnaryExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnaryExpression performs a merge with any union data inside the Expression, using the provided UnaryExpression
func (t *Expression) MergeUnaryExpression(v UnaryExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Expression) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Expression) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCounterResult returns the union data inside the MetricResult as a CounterResult
func (t MetricResult) AsCounterResult() (CounterResult, error) {
	var body CounterResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCounterResult overwrites any union data inside the MetricResult as the provided CounterResult
func (t *MetricResult) FromCounterResult(v CounterResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCounterResult performs a merge with any union data inside the MetricResult, using the provided CounterResult
func (t *MetricResult) MergeCounterResult(v CounterResult) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimerResult returns the union data inside the MetricResult as a TimerResult
func (t MetricResult) AsTimerResult() (TimerResult, error) {
	var body TimerResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimerResult overwrites any union data inside the MetricResult as the provided TimerResult
func (t *MetricResult) FromTimerResult(v TimerResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimerResult performs a merge with any union data inside the MetricResult, using the provided TimerResult
func (t *MetricResult) MergeTimerResult(v TimerResult) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOAuthClientCredentialsRequest returns the union data inside the OAuthTokenRequest as a OAuthClientCredentialsRequest
func (t OAuthTokenRequest) AsOAuthClientCredentialsRequest() (OAuthClientCredentialsRequest, error) {
	var body OAuthClientCredentialsRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOAuthClientCredentialsRequest overwrites any union data inside the OAuthTokenRequest as the provided OAuthClientCredentialsRequest
func (t *OAuthTokenRequest) FromOAuthClientCredentialsRequest(v OAuthClientCredentialsRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOAuthClientCredentialsRequest performs a merge with any union data inside the OAuthTokenRequest, using the provided OAuthClientCredentialsRequest
func (t *OAuthTokenRequest) MergeOAuthClientCredentialsRequest(v OAuthClientCredentialsRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOAuthTokenExchangeRequest returns the union data inside the OAuthTokenRequest as a OAuthTokenExchangeRequest
func (t OAuthTokenRequest) AsOAuthTokenExchangeRequest() (OAuthTokenExchangeRequest, error) {
	var body OAuthTokenExchangeRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOAuthTokenExchangeRequest overwrites any union data inside the OAuthTokenRequest as the provided OAuthTokenExchangeRequest
func (t *OAuthTokenRequest) FromOAuthTokenExchangeRequest(v OAuthTokenExchangeRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOAuthTokenExchangeRequest performs a merge with any union data inside the OAuthTokenRequest, using the provided OAuthTokenExchangeRequest
func (t *OAuthTokenRequest) MergeOAuthTokenExchangeRequest(v OAuthTokenExchangeRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OAuthTokenRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OAuthTokenRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScanReport returns the union data inside the ReportMetricsRequest as a ScanReport
func (t ReportMetricsRequest) AsScanReport() (ScanReport, error) {
	var body ScanReport
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScanReport overwrites any union data inside the ReportMetricsRequest as the provided ScanReport
func (t *ReportMetricsRequest) FromScanReport(v ScanReport) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScanReport performs a merge with any union data inside the ReportMetricsRequest, using the provided ScanReport
func (t *ReportMetricsRequest) MergeScanReport(v ScanReport) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommitReport returns the union data inside the ReportMetricsRequest as a CommitReport
func (t ReportMetricsRequest) AsCommitReport() (CommitReport, error) {
	var body CommitReport
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommitReport overwrites any union data inside the ReportMetricsRequest as the provided CommitReport
func (t *ReportMetricsRequest) FromCommitReport(v CommitReport) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommitReport performs a merge with any union data inside the ReportMetricsRequest, using the provided CommitReport
func (t *ReportMetricsRequest) MergeCommitReport(v CommitReport) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReportMetricsRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["report-type"], err = json.Marshal(t.ReportType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'report-type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ReportMetricsRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["report-type"]; found {
		err = json.Unmarshal(raw, &t.ReportType)
		if err != nil {
			return fmt.Errorf("error reading 'report-type': %w", err)
		}
	}

	return err
}

// AsAssertCreate returns the union data inside the TableRequirement as a AssertCreate
func (t TableRequirement) AsAssertCreate() (AssertCreate, error) {
	var body AssertCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertCreate overwrites any union data inside the TableRequirement as the provided AssertCreate
func (t *TableRequirement) FromAssertCreate(v AssertCreate) error {
	v.Type = "assert-create"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertCreate performs a merge with any union data inside the TableRequirement, using the provided AssertCreate
func (t *TableRequirement) MergeAssertCreate(v AssertCreate) error {
	v.Type = "assert-create"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertTableUUID returns the union data inside the TableRequirement as a AssertTableUUID
func (t TableRequirement) AsAssertTableUUID() (AssertTableUUID, error) {
	var body AssertTableUUID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertTableUUID overwrites any union data inside the TableRequirement as the provided AssertTableUUID
func (t *TableRequirement) FromAssertTableUUID(v AssertTableUUID) error {
	v.Type = "assert-table-uuid"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertTableUUID performs a merge with any union data inside the TableRequirement, using the provided AssertTableUUID
func (t *TableRequirement) MergeAssertTableUUID(v AssertTableUUID) error {
	v.Type = "assert-table-uuid"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertRefSnapshotId returns the union data inside the TableRequirement as a AssertRefSnapshotId
func (t TableRequirement) AsAssertRefSnapshotId() (AssertRefSnapshotId, error) {
	var body AssertRefSnapshotId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertRefSnapshotId overwrites any union data inside the TableRequirement as the provided AssertRefSnapshotId
func (t *TableRequirement) FromAssertRefSnapshotId(v AssertRefSnapshotId) error {
	v.Type = "assert-ref-snapshot-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertRefSnapshotId performs a merge with any union data inside the TableRequirement, using the provided AssertRefSnapshotId
func (t *TableRequirement) MergeAssertRefSnapshotId(v AssertRefSnapshotId) error {
	v.Type = "assert-ref-snapshot-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertLastAssignedFieldId returns the union data inside the TableRequirement as a AssertLastAssignedFieldId
func (t TableRequirement) AsAssertLastAssignedFieldId() (AssertLastAssignedFieldId, error) {
	var body AssertLastAssignedFieldId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertLastAssignedFieldId overwrites any union data inside the TableRequirement as the provided AssertLastAssignedFieldId
func (t *TableRequirement) FromAssertLastAssignedFieldId(v AssertLastAssignedFieldId) error {
	v.Type = "assert-last-assigned-field-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertLastAssignedFieldId performs a merge with any union data inside the TableRequirement, using the provided AssertLastAssignedFieldId
func (t *TableRequirement) MergeAssertLastAssignedFieldId(v AssertLastAssignedFieldId) error {
	v.Type = "assert-last-assigned-field-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertCurrentSchemaId returns the union data inside the TableRequirement as a AssertCurrentSchemaId
func (t TableRequirement) AsAssertCurrentSchemaId() (AssertCurrentSchemaId, error) {
	var body AssertCurrentSchemaId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertCurrentSchemaId overwrites any union data inside the TableRequirement as the provided AssertCurrentSchemaId
func (t *TableRequirement) FromAssertCurrentSchemaId(v AssertCurrentSchemaId) error {
	v.Type = "assert-current-schema-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertCurrentSchemaId performs a merge with any union data inside the TableRequirement, using the provided AssertCurrentSchemaId
func (t *TableRequirement) MergeAssertCurrentSchemaId(v AssertCurrentSchemaId) error {
	v.Type = "assert-current-schema-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertLastAssignedPartitionId returns the union data inside the TableRequirement as a AssertLastAssignedPartitionId
func (t TableRequirement) AsAssertLastAssignedPartitionId() (AssertLastAssignedPartitionId, error) {
	var body AssertLastAssignedPartitionId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertLastAssignedPartitionId overwrites any union data inside the TableRequirement as the provided AssertLastAssignedPartitionId
func (t *TableRequirement) FromAssertLastAssignedPartitionId(v AssertLastAssignedPartitionId) error {
	v.Type = "assert-last-assigned-partition-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertLastAssignedPartitionId performs a merge with any union data inside the TableRequirement, using the provided AssertLastAssignedPartitionId
func (t *TableRequirement) MergeAssertLastAssignedPartitionId(v AssertLastAssignedPartitionId) error {
	v.Type = "assert-last-assigned-partition-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertDefaultSpecId returns the union data inside the TableRequirement as a AssertDefaultSpecId
func (t TableRequirement) AsAssertDefaultSpecId() (AssertDefaultSpecId, error) {
	var body AssertDefaultSpecId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertDefaultSpecId overwrites any union data inside the TableRequirement as the provided AssertDefaultSpecId
func (t *TableRequirement) FromAssertDefaultSpecId(v AssertDefaultSpecId) error {
	v.Type = "assert-default-spec-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertDefaultSpecId performs a merge with any union data inside the TableRequirement, using the provided AssertDefaultSpecId
func (t *TableRequirement) MergeAssertDefaultSpecId(v AssertDefaultSpecId) error {
	v.Type = "assert-default-spec-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssertDefaultSortOrderId returns the union data inside the TableRequirement as a AssertDefaultSortOrderId
func (t TableRequirement) AsAssertDefaultSortOrderId() (AssertDefaultSortOrderId, error) {
	var body AssertDefaultSortOrderId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertDefaultSortOrderId overwrites any union data inside the TableRequirement as the provided AssertDefaultSortOrderId
func (t *TableRequirement) FromAssertDefaultSortOrderId(v AssertDefaultSortOrderId) error {
	v.Type = "assert-default-sort-order-id"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertDefaultSortOrderId performs a merge with any union data inside the TableRequirement, using the provided AssertDefaultSortOrderId
func (t *TableRequirement) MergeAssertDefaultSortOrderId(v AssertDefaultSortOrderId) error {
	v.Type = "assert-default-sort-order-id"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TableRequirement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TableRequirement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "assert-create":
		return t.AsAssertCreate()
	case "assert-current-schema-id":
		return t.AsAssertCurrentSchemaId()
	case "assert-default-sort-order-id":
		return t.AsAssertDefaultSortOrderId()
	case "assert-default-spec-id":
		return t.AsAssertDefaultSpecId()
	case "assert-last-assigned-field-id":
		return t.AsAssertLastAssignedFieldId()
	case "assert-last-assigned-partition-id":
		return t.AsAssertLastAssignedPartitionId()
	case "assert-ref-snapshot-id":
		return t.AsAssertRefSnapshotId()
	case "assert-table-uuid":
		return t.AsAssertTableUUID()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TableRequirement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TableRequirement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssignUUIDUpdate returns the union data inside the TableUpdate as a AssignUUIDUpdate
func (t TableUpdate) AsAssignUUIDUpdate() (AssignUUIDUpdate, error) {
	var body AssignUUIDUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssignUUIDUpdate overwrites any union data inside the TableUpdate as the provided AssignUUIDUpdate
func (t *TableUpdate) FromAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssignUUIDUpdate performs a merge with any union data inside the TableUpdate, using the provided AssignUUIDUpdate
func (t *TableUpdate) MergeAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeFormatVersionUpdate returns the union data inside the TableUpdate as a UpgradeFormatVersionUpdate
func (t TableUpdate) AsUpgradeFormatVersionUpdate() (UpgradeFormatVersionUpdate, error) {
	var body UpgradeFormatVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeFormatVersionUpdate overwrites any union data inside the TableUpdate as the provided UpgradeFormatVersionUpdate
func (t *TableUpdate) FromUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeFormatVersionUpdate performs a merge with any union data inside the TableUpdate, using the provided UpgradeFormatVersionUpdate
func (t *TableUpdate) MergeUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSchemaUpdate returns the union data inside the TableUpdate as a AddSchemaUpdate
func (t TableUpdate) AsAddSchemaUpdate() (AddSchemaUpdate, error) {
	var body AddSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSchemaUpdate overwrites any union data inside the TableUpdate as the provided AddSchemaUpdate
func (t *TableUpdate) FromAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSchemaUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSchemaUpdate
func (t *TableUpdate) MergeAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetCurrentSchemaUpdate returns the union data inside the TableUpdate as a SetCurrentSchemaUpdate
func (t TableUpdate) AsSetCurrentSchemaUpdate() (SetCurrentSchemaUpdate, error) {
	var body SetCurrentSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetCurrentSchemaUpdate overwrites any union data inside the TableUpdate as the provided SetCurrentSchemaUpdate
func (t *TableUpdate) FromSetCurrentSchemaUpdate(v SetCurrentSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetCurrentSchemaUpdate performs a merge with any union data inside the TableUpdate, using the provided SetCurrentSchemaUpdate
func (t *TableUpdate) MergeSetCurrentSchemaUpdate(v SetCurrentSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddPartitionSpecUpdate returns the union data inside the TableUpdate as a AddPartitionSpecUpdate
func (t TableUpdate) AsAddPartitionSpecUpdate() (AddPartitionSpecUpdate, error) {
	var body AddPartitionSpecUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddPartitionSpecUpdate overwrites any union data inside the TableUpdate as the provided AddPartitionSpecUpdate
func (t *TableUpdate) FromAddPartitionSpecUpdate(v AddPartitionSpecUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddPartitionSpecUpdate performs a merge with any union data inside the TableUpdate, using the provided AddPartitionSpecUpdate
func (t *TableUpdate) MergeAddPartitionSpecUpdate(v AddPartitionSpecUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetDefaultSpecUpdate returns the union data inside the TableUpdate as a SetDefaultSpecUpdate
func (t TableUpdate) AsSetDefaultSpecUpdate() (SetDefaultSpecUpdate, error) {
	var body SetDefaultSpecUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetDefaultSpecUpdate overwrites any union data inside the TableUpdate as the provided SetDefaultSpecUpdate
func (t *TableUpdate) FromSetDefaultSpecUpdate(v SetDefaultSpecUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetDefaultSpecUpdate performs a merge with any union data inside the TableUpdate, using the provided SetDefaultSpecUpdate
func (t *TableUpdate) MergeSetDefaultSpecUpdate(v SetDefaultSpecUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSortOrderUpdate returns the union data inside the TableUpdate as a AddSortOrderUpdate
func (t TableUpdate) AsAddSortOrderUpdate() (AddSortOrderUpdate, error) {
	var body AddSortOrderUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSortOrderUpdate overwrites any union data inside the TableUpdate as the provided AddSortOrderUpdate
func (t *TableUpdate) FromAddSortOrderUpdate(v AddSortOrderUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSortOrderUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSortOrderUpdate
func (t *TableUpdate) MergeAddSortOrderUpdate(v AddSortOrderUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetDefaultSortOrderUpdate returns the union data inside the TableUpdate as a SetDefaultSortOrderUpdate
func (t TableUpdate) AsSetDefaultSortOrderUpdate() (SetDefaultSortOrderUpdate, error) {
	var body SetDefaultSortOrderUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetDefaultSortOrderUpdate overwrites any union data inside the TableUpdate as the provided SetDefaultSortOrderUpdate
func (t *TableUpdate) FromSetDefaultSortOrderUpdate(v SetDefaultSortOrderUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetDefaultSortOrderUpdate performs a merge with any union data inside the TableUpdate, using the provided SetDefaultSortOrderUpdate
func (t *TableUpdate) MergeSetDefaultSortOrderUpdate(v SetDefaultSortOrderUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSnapshotUpdate returns the union data inside the TableUpdate as a AddSnapshotUpdate
func (t TableUpdate) AsAddSnapshotUpdate() (AddSnapshotUpdate, error) {
	var body AddSnapshotUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSnapshotUpdate overwrites any union data inside the TableUpdate as the provided AddSnapshotUpdate
func (t *TableUpdate) FromAddSnapshotUpdate(v AddSnapshotUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSnapshotUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSnapshotUpdate
func (t *TableUpdate) MergeAddSnapshotUpdate(v AddSnapshotUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetSnapshotRefUpdate returns the union data inside the TableUpdate as a SetSnapshotRefUpdate
func (t TableUpdate) AsSetSnapshotRefUpdate() (SetSnapshotRefUpdate, error) {
	var body SetSnapshotRefUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetSnapshotRefUpdate overwrites any union data inside the TableUpdate as the provided SetSnapshotRefUpdate
func (t *TableUpdate) FromSetSnapshotRefUpdate(v SetSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetSnapshotRefUpdate performs a merge with any union data inside the TableUpdate, using the provided SetSnapshotRefUpdate
func (t *TableUpdate) MergeSetSnapshotRefUpdate(v SetSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveSnapshotsUpdate returns the union data inside the TableUpdate as a RemoveSnapshotsUpdate
func (t TableUpdate) AsRemoveSnapshotsUpdate() (RemoveSnapshotsUpdate, error) {
	var body RemoveSnapshotsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveSnapshotsUpdate overwrites any union data inside the TableUpdate as the provided RemoveSnapshotsUpdate
func (t *TableUpdate) FromRemoveSnapshotsUpdate(v RemoveSnapshotsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveSnapshotsUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveSnapshotsUpdate
func (t *TableUpdate) MergeRemoveSnapshotsUpdate(v RemoveSnapshotsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveSnapshotRefUpdate returns the union data inside the TableUpdate as a RemoveSnapshotRefUpdate
func (t TableUpdate) AsRemoveSnapshotRefUpdate() (RemoveSnapshotRefUpdate, error) {
	var body RemoveSnapshotRefUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveSnapshotRefUpdate overwrites any union data inside the TableUpdate as the provided RemoveSnapshotRefUpdate
func (t *TableUpdate) FromRemoveSnapshotRefUpdate(v RemoveSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveSnapshotRefUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveSnapshotRefUpdate
func (t *TableUpdate) MergeRemoveSnapshotRefUpdate(v RemoveSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetLocationUpdate returns the union data inside the TableUpdate as a SetLocationUpdate
func (t TableUpdate) AsSetLocationUpdate() (SetLocationUpdate, error) {
	var body SetLocationUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetLocationUpdate overwrites any union data inside the TableUpdate as the provided SetLocationUpdate
func (t *TableUpdate) FromSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetLocationUpdate performs a merge with any union data inside the TableUpdate, using the provided SetLocationUpdate
func (t *TableUpdate) MergeSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetPropertiesUpdate returns the union data inside the TableUpdate as a SetPropertiesUpdate
func (t TableUpdate) AsSetPropertiesUpdate() (SetPropertiesUpdate, error) {
	var body SetPropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPropertiesUpdate overwrites any union data inside the TableUpdate as the provided SetPropertiesUpdate
func (t *TableUpdate) FromSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPropertiesUpdate performs a merge with any union data inside the TableUpdate, using the provided SetPropertiesUpdate
func (t *TableUpdate) MergeSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemovePropertiesUpdate returns the union data inside the TableUpdate as a RemovePropertiesUpdate
func (t TableUpdate) AsRemovePropertiesUpdate() (RemovePropertiesUpdate, error) {
	var body RemovePropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemovePropertiesUpdate overwrites any union data inside the TableUpdate as the provided RemovePropertiesUpdate
func (t *TableUpdate) FromRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemovePropertiesUpdate performs a merge with any union data inside the TableUpdate, using the provided RemovePropertiesUpdate
func (t *TableUpdate) MergeRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetStatisticsUpdate returns the union data inside the TableUpdate as a SetStatisticsUpdate
func (t TableUpdate) AsSetStatisticsUpdate() (SetStatisticsUpdate, error) {
	var body SetStatisticsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetStatisticsUpdate overwrites any union data inside the TableUpdate as the provided SetStatisticsUpdate
func (t *TableUpdate) FromSetStatisticsUpdate(v SetStatisticsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetStatisticsUpdate performs a merge with any union data inside the TableUpdate, using the provided SetStatisticsUpdate
func (t *TableUpdate) MergeSetStatisticsUpdate(v SetStatisticsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveStatisticsUpdate returns the union data inside the TableUpdate as a RemoveStatisticsUpdate
func (t TableUpdate) AsRemoveStatisticsUpdate() (RemoveStatisticsUpdate, error) {
	var body RemoveStatisticsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveStatisticsUpdate overwrites any union data inside the TableUpdate as the provided RemoveStatisticsUpdate
func (t *TableUpdate) FromRemoveStatisticsUpdate(v RemoveStatisticsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveStatisticsUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveStatisticsUpdate
func (t *TableUpdate) MergeRemoveStatisticsUpdate(v RemoveStatisticsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TableUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TableUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReference returns the union data inside the Term as a Reference
func (t Term) AsReference() (Reference, error) {
	var body Reference
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReference overwrites any union data inside the Term as the provided Reference
func (t *Term) FromReference(v Reference) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReference performs a merge with any union data inside the Term, using the provided Reference
func (t *Term) MergeReference(v Reference) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransformTerm returns the union data inside the Term as a TransformTerm
func (t Term) AsTransformTerm() (TransformTerm, error) {
	var body TransformTerm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformTerm overwrites any union data inside the Term as the provided TransformTerm
func (t *Term) FromTransformTerm(v TransformTerm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformTerm performs a merge with any union data inside the Term, using the provided TransformTerm
func (t *Term) MergeTransformTerm(v TransformTerm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Term) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Term) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrimitiveType returns the union data inside the Type as a PrimitiveType
func (t Type) AsPrimitiveType() (PrimitiveType, error) {
	var body PrimitiveType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveType overwrites any union data inside the Type as the provided PrimitiveType
func (t *Type) FromPrimitiveType(v PrimitiveType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveType performs a merge with any union data inside the Type, using the provided PrimitiveType
func (t *Type) MergePrimitiveType(v PrimitiveType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStructType returns the union data inside the Type as a StructType
func (t Type) AsStructType() (StructType, error) {
	var body StructType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStructType overwrites any union data inside the Type as the provided StructType
func (t *Type) FromStructType(v StructType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStructType performs a merge with any union data inside the Type, using the provided StructType
func (t *Type) MergeStructType(v StructType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsListType returns the union data inside the Type as a ListType
func (t Type) AsListType() (ListType, error) {
	var body ListType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListType overwrites any union data inside the Type as the provided ListType
func (t *Type) FromListType(v ListType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListType performs a merge with any union data inside the Type, using the provided ListType
func (t *Type) MergeListType(v ListType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapType returns the union data inside the Type as a MapType
func (t Type) AsMapType() (MapType, error) {
	var body MapType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapType overwrites any union data inside the Type as the provided MapType
func (t *Type) FromMapType(v MapType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapType performs a merge with any union data inside the Type, using the provided MapType
func (t *Type) MergeMapType(v MapType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSQLViewRepresentation returns the union data inside the ViewRepresentation as a SQLViewRepresentation
func (t ViewRepresentation) AsSQLViewRepresentation() (SQLViewRepresentation, error) {
	var body SQLViewRepresentation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSQLViewRepresentation overwrites any union data inside the ViewRepresentation as the provided SQLViewRepresentation
func (t *ViewRepresentation) FromSQLViewRepresentation(v SQLViewRepresentation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSQLViewRepresentation performs a merge with any union data inside the ViewRepresentation, using the provided SQLViewRepresentation
func (t *ViewRepresentation) MergeSQLViewRepresentation(v SQLViewRepresentation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewRepresentation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewRepresentation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssertViewUUID returns the union data inside the ViewRequirement as a AssertViewUUID
func (t ViewRequirement) AsAssertViewUUID() (AssertViewUUID, error) {
	var body AssertViewUUID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertViewUUID overwrites any union data inside the ViewRequirement as the provided AssertViewUUID
func (t *ViewRequirement) FromAssertViewUUID(v AssertViewUUID) error {
	v.Type = "assert-view-uuid"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertViewUUID performs a merge with any union data inside the ViewRequirement, using the provided AssertViewUUID
func (t *ViewRequirement) MergeAssertViewUUID(v AssertViewUUID) error {
	v.Type = "assert-view-uuid"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewRequirement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ViewRequirement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "assert-view-uuid":
		return t.AsAssertViewUUID()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ViewRequirement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewRequirement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssignUUIDUpdate returns the union data inside the ViewUpdate as a AssignUUIDUpdate
func (t ViewUpdate) AsAssignUUIDUpdate() (AssignUUIDUpdate, error) {
	var body AssignUUIDUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssignUUIDUpdate overwrites any union data inside the ViewUpdate as the provided AssignUUIDUpdate
func (t *ViewUpdate) FromAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssignUUIDUpdate performs a merge with any union data inside the ViewUpdate, using the provided AssignUUIDUpdate
func (t *ViewUpdate) MergeAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeFormatVersionUpdate returns the union data inside the ViewUpdate as a UpgradeFormatVersionUpdate
func (t ViewUpdate) AsUpgradeFormatVersionUpdate() (UpgradeFormatVersionUpdate, error) {
	var body UpgradeFormatVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeFormatVersionUpdate overwrites any union data inside the ViewUpdate as the provided UpgradeFormatVersionUpdate
func (t *ViewUpdate) FromUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeFormatVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided UpgradeFormatVersionUpdate
func (t *ViewUpdate) MergeUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSchemaUpdate returns the union data inside the ViewUpdate as a AddSchemaUpdate
func (t ViewUpdate) AsAddSchemaUpdate() (AddSchemaUpdate, error) {
	var body AddSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSchemaUpdate overwrites any union data inside the ViewUpdate as the provided AddSchemaUpdate
func (t *ViewUpdate) FromAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSchemaUpdate performs a merge with any union data inside the ViewUpdate, using the provided AddSchemaUpdate
func (t *ViewUpdate) MergeAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetLocationUpdate returns the union data inside the ViewUpdate as a SetLocationUpdate
func (t ViewUpdate) AsSetLocationUpdate() (SetLocationUpdate, error) {
	var body SetLocationUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetLocationUpdate overwrites any union data inside the ViewUpdate as the provided SetLocationUpdate
func (t *ViewUpdate) FromSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetLocationUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetLocationUpdate
func (t *ViewUpdate) MergeSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetPropertiesUpdate returns the union data inside the ViewUpdate as a SetPropertiesUpdate
func (t ViewUpdate) AsSetPropertiesUpdate() (SetPropertiesUpdate, error) {
	var body SetPropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPropertiesUpdate overwrites any union data inside the ViewUpdate as the provided SetPropertiesUpdate
func (t *ViewUpdate) FromSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPropertiesUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetPropertiesUpdate
func (t *ViewUpdate) MergeSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemovePropertiesUpdate returns the union data inside the ViewUpdate as a RemovePropertiesUpdate
func (t ViewUpdate) AsRemovePropertiesUpdate() (RemovePropertiesUpdate, error) {
	var body RemovePropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemovePropertiesUpdate overwrites any union data inside the ViewUpdate as the provided RemovePropertiesUpdate
func (t *ViewUpdate) FromRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemovePropertiesUpdate performs a merge with any union data inside the ViewUpdate, using the provided RemovePropertiesUpdate
func (t *ViewUpdate) MergeRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddViewVersionUpdate returns the union data inside the ViewUpdate as a AddViewVersionUpdate
func (t ViewUpdate) AsAddViewVersionUpdate() (AddViewVersionUpdate, error) {
	var body AddViewVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddViewVersionUpdate overwrites any union data inside the ViewUpdate as the provided AddViewVersionUpdate
func (t *ViewUpdate) FromAddViewVersionUpdate(v AddViewVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddViewVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided AddViewVersionUpdate
func (t *ViewUpdate) MergeAddViewVersionUpdate(v AddViewVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetCurrentViewVersionUpdate returns the union data inside the ViewUpdate as a SetCurrentViewVersionUpdate
func (t ViewUpdate) AsSetCurrentViewVersionUpdate() (SetCurrentViewVersionUpdate, error) {
	var body SetCurrentViewVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetCurrentViewVersionUpdate overwrites any union data inside the ViewUpdate as the provided SetCurrentViewVersionUpdate
func (t *ViewUpdate) FromSetCurrentViewVersionUpdate(v SetCurrentViewVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetCurrentViewVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetCurrentViewVersionUpdate
func (t *ViewUpdate) MergeSetCurrentViewVersionUpdate(v SetCurrentViewVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConfig request
	GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNamespaces request
	ListNamespaces(ctx context.Context, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNamespaceWithBody request with any body
	CreateNamespaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNamespace(ctx context.Context, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropNamespace request
	DropNamespace(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadNamespaceMetadata request
	LoadNamespaceMetadata(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespaceExists request
	NamespaceExists(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePropertiesWithBody request with any body
	UpdatePropertiesWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProperties(ctx context.Context, namespace Namespace, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterTableWithBody request with any body
	RegisterTableWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterTable(ctx context.Context, namespace Namespace, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, namespace Namespace, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, namespace Namespace, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, namespace Namespace, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropTable request
	DropTable(ctx context.Context, namespace Namespace, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadTable request
	LoadTable(ctx context.Context, namespace Namespace, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableExists request
	TableExists(ctx context.Context, namespace Namespace, table Table, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTableWithBody request with any body
	UpdateTableWithBody(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTable(ctx context.Context, namespace Namespace, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportMetricsWithBody request with any body
	ReportMetricsWithBody(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportMetrics(ctx context.Context, namespace Namespace, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListViews request
	ListViews(ctx context.Context, namespace Namespace, params *ListViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewWithBody request with any body
	CreateViewWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateView(ctx context.Context, namespace Namespace, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropView request
	DropView(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadView request
	LoadView(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViewExists request
	ViewExists(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceViewWithBody request with any body
	ReplaceViewWithBody(ctx context.Context, namespace Namespace, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceView(ctx context.Context, namespace Namespace, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenWithBody request with any body
	GetTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTokenWithFormdataBody(ctx context.Context, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameTableWithBody request with any body
	RenameTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameTable(ctx context.Context, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransactionWithBody request with any body
	CommitTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitTransaction(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameViewWithBody request with any body
	RenameViewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameView(ctx context.Context, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNamespaces(ctx context.Context, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNamespacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespace(ctx context.Context, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropNamespace(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropNamespaceRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadNamespaceMetadata(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadNamespaceMetadataRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceExists(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespaceExistsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePropertiesWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProperties(ctx context.Context, namespace Namespace, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTableWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTableRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTable(ctx context.Context, namespace Namespace, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTableRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, namespace Namespace, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, namespace Namespace, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, namespace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, namespace Namespace, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, namespace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropTable(ctx context.Context, namespace Namespace, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropTableRequest(c.Server, namespace, table, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadTable(ctx context.Context, namespace Namespace, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadTableRequest(c.Server, namespace, table, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableExists(ctx context.Context, namespace Namespace, table Table, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableExistsRequest(c.Server, namespace, table)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableWithBody(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequestWithBody(c.Server, namespace, table, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTable(ctx context.Context, namespace Namespace, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequest(c.Server, namespace, table, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportMetricsWithBody(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportMetricsRequestWithBody(c.Server, namespace, table, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportMetrics(ctx context.Context, namespace Namespace, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportMetricsRequest(c.Server, namespace, table, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListViews(ctx context.Context, namespace Namespace, params *ListViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListViewsRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewWithBody(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateView(ctx context.Context, namespace Namespace, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropView(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropViewRequest(c.Server, namespace, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadView(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadViewRequest(c.Server, namespace, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewExists(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewExistsRequest(c.Server, namespace, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceViewWithBody(ctx context.Context, namespace Namespace, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceViewRequestWithBody(c.Server, namespace, view, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceView(ctx context.Context, namespace Namespace, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceViewRequest(c.Server, namespace, view, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenWithFormdataBody(ctx context.Context, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameTableRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameTable(ctx context.Context, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameTableRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameViewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameViewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameView(ctx context.Context, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameViewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, params *GetConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Warehouse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "warehouse", runtime.ParamLocationQuery, *params.Warehouse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNamespacesRequest generates requests for ListNamespaces
func NewListNamespacesRequest(server string, params *ListNamespacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNamespaceRequest calls the generic CreateNamespace builder with application/json body
func NewCreateNamespaceRequest(server string, body CreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNamespaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNamespaceRequestWithBody generates requests for CreateNamespace with any type of body
func NewCreateNamespaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropNamespaceRequest generates requests for DropNamespace
func NewDropNamespaceRequest(server string, namespace Namespace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadNamespaceMetadataRequest generates requests for LoadNamespaceMetadata
func NewLoadNamespaceMetadataRequest(server string, namespace Namespace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceExistsRequest generates requests for NamespaceExists
func NewNamespaceExistsRequest(server string, namespace Namespace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePropertiesRequest calls the generic UpdateProperties builder with application/json body
func NewUpdatePropertiesRequest(server string, namespace Namespace, body UpdatePropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePropertiesRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewUpdatePropertiesRequestWithBody generates requests for UpdateProperties with any type of body
func NewUpdatePropertiesRequestWithBody(server string, namespace Namespace, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegisterTableRequest calls the generic RegisterTable builder with application/json body
func NewRegisterTableRequest(server string, namespace Namespace, body RegisterTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterTableRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewRegisterTableRequestWithBody generates requests for RegisterTable with any type of body
func NewRegisterTableRequestWithBody(server string, namespace Namespace, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/register", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, namespace Namespace, params *ListTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, namespace Namespace, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, namespace, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, namespace Namespace, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIcebergAccessDelegation != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Iceberg-Access-Delegation", runtime.ParamLocationHeader, *params.XIcebergAccessDelegation)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Iceberg-Access-Delegation", headerParam0)
		}

	}

	return req, nil
}

// NewDropTableRequest generates requests for DropTable
func NewDropTableRequest(server string, namespace Namespace, table Table, params *DropTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PurgeRequested != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purgeRequested", runtime.ParamLocationQuery, *params.PurgeRequested); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadTableRequest generates requests for LoadTable
func NewLoadTableRequest(server string, namespace Namespace, table Table, params *LoadTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Snapshots != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshots", runtime.ParamLocationQuery, *params.Snapshots); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XIcebergAccessDelegation != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Iceberg-Access-Delegation", runtime.ParamLocationHeader, *params.XIcebergAccessDelegation)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Iceberg-Access-Delegation", headerParam0)
		}

	}

	return req, nil
}

// NewTableExistsRequest generates requests for TableExists
func NewTableExistsRequest(server string, namespace Namespace, table Table) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTableRequest calls the generic UpdateTable builder with application/json body
func NewUpdateTableRequest(server string, namespace Namespace, table Table, body UpdateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTableRequestWithBody(server, namespace, table, "application/json", bodyReader)
}

// NewUpdateTableRequestWithBody generates requests for UpdateTable with any type of body
func NewUpdateTableRequestWithBody(server string, namespace Namespace, table Table, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReportMetricsRequest calls the generic ReportMetrics builder with application/json body
func NewReportMetricsRequest(server string, namespace Namespace, table Table, body ReportMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportMetricsRequestWithBody(server, namespace, table, "application/json", bodyReader)
}

// NewReportMetricsRequestWithBody generates requests for ReportMetrics with any type of body
func NewReportMetricsRequestWithBody(server string, namespace Namespace, table Table, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/tables/%s/metrics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListViewsRequest generates requests for ListViews
func NewListViewsRequest(server string, namespace Namespace, params *ListViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewRequest calls the generic CreateView builder with application/json body
func NewCreateViewRequest(server string, namespace Namespace, body CreateViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateViewRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewCreateViewRequestWithBody generates requests for CreateView with any type of body
func NewCreateViewRequestWithBody(server string, namespace Namespace, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropViewRequest generates requests for DropView
func NewDropViewRequest(server string, namespace Namespace, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadViewRequest generates requests for LoadView
func NewLoadViewRequest(server string, namespace Namespace, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewViewExistsRequest generates requests for ViewExists
func NewViewExistsRequest(server string, namespace Namespace, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceViewRequest calls the generic ReplaceView builder with application/json body
func NewReplaceViewRequest(server string, namespace Namespace, view View, body ReplaceViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceViewRequestWithBody(server, namespace, view, "application/json", bodyReader)
}

// NewReplaceViewRequestWithBody generates requests for ReplaceView with any type of body
func NewReplaceViewRequestWithBody(server string, namespace Namespace, view View, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespaces/%s/views/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTokenRequestWithFormdataBody calls the generic GetToken builder with application/x-www-form-urlencoded body
func NewGetTokenRequestWithFormdataBody(server string, body GetTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetTokenRequestWithBody generates requests for GetToken with any type of body
func NewGetTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameTableRequest calls the generic RenameTable builder with application/json body
func NewRenameTableRequest(server string, body RenameTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameTableRequestWithBody(server, "application/json", bodyReader)
}

// NewRenameTableRequestWithBody generates requests for RenameTable with any type of body
func NewRenameTableRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tables/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitTransactionRequest calls the generic CommitTransaction builder with application/json body
func NewCommitTransactionRequest(server string, body CommitTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewCommitTransactionRequestWithBody generates requests for CommitTransaction with any type of body
func NewCommitTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/commit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameViewRequest calls the generic RenameView builder with application/json body
func NewRenameViewRequest(server string, body RenameViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameViewRequestWithBody(server, "application/json", bodyReader)
}

// NewRenameViewRequestWithBody generates requests for RenameView with any type of body
func NewRenameViewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/views/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Error satisfies Error for ErrorModel.
func (e *ErrorModel) Error() string {
	return e.Message
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigServerResponse, error)

	// ListNamespacesWithResponse request
	ListNamespacesWithResponse(ctx context.Context, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*ListNamespacesServerResponse, error)

	// CreateNamespaceWithBodyWithResponse request with any body
	CreateNamespaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceServerResponse, error)

	CreateNamespaceWithResponse(ctx context.Context, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceServerResponse, error)

	// DropNamespaceWithResponse request
	DropNamespaceWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*DropNamespaceServerResponse, error)

	// LoadNamespaceMetadataWithResponse request
	LoadNamespaceMetadataWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*LoadNamespaceMetadataServerResponse, error)

	// NamespaceExistsWithResponse request
	NamespaceExistsWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*NamespaceExistsServerResponse, error)

	// UpdatePropertiesWithBodyWithResponse request with any body
	UpdatePropertiesWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesServerResponse, error)

	UpdatePropertiesWithResponse(ctx context.Context, namespace Namespace, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePropertiesServerResponse, error)

	// RegisterTableWithBodyWithResponse request with any body
	RegisterTableWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTableServerResponse, error)

	RegisterTableWithResponse(ctx context.Context, namespace Namespace, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTableServerResponse, error)

	// ListTablesWithResponse request
	ListTablesWithResponse(ctx context.Context, namespace Namespace, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesServerResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, namespace Namespace, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableServerResponse, error)

	CreateTableWithResponse(ctx context.Context, namespace Namespace, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableServerResponse, error)

	// DropTableWithResponse request
	DropTableWithResponse(ctx context.Context, namespace Namespace, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*DropTableServerResponse, error)

	// LoadTableWithResponse request
	LoadTableWithResponse(ctx context.Context, namespace Namespace, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*LoadTableServerResponse, error)

	// TableExistsWithResponse request
	TableExistsWithResponse(ctx context.Context, namespace Namespace, table Table, reqEditors ...RequestEditorFn) (*TableExistsServerResponse, error)

	// UpdateTableWithBodyWithResponse request with any body
	UpdateTableWithBodyWithResponse(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableServerResponse, error)

	UpdateTableWithResponse(ctx context.Context, namespace Namespace, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableServerResponse, error)

	// ReportMetricsWithBodyWithResponse request with any body
	ReportMetricsWithBodyWithResponse(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportMetricsServerResponse, error)

	ReportMetricsWithResponse(ctx context.Context, namespace Namespace, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportMetricsServerResponse, error)

	// ListViewsWithResponse request
	ListViewsWithResponse(ctx context.Context, namespace Namespace, params *ListViewsParams, reqEditors ...RequestEditorFn) (*ListViewsServerResponse, error)

	// CreateViewWithBodyWithResponse request with any body
	CreateViewWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewServerResponse, error)

	CreateViewWithResponse(ctx context.Context, namespace Namespace, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateViewServerResponse, error)

	// DropViewWithResponse request
	DropViewWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*DropViewServerResponse, error)

	// LoadViewWithResponse request
	LoadViewWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*LoadViewServerResponse, error)

	// ViewExistsWithResponse request
	ViewExistsWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*ViewExistsServerResponse, error)

	// ReplaceViewWithBodyWithResponse request with any body
	ReplaceViewWithBodyWithResponse(ctx context.Context, namespace Namespace, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceViewServerResponse, error)

	ReplaceViewWithResponse(ctx context.Context, namespace Namespace, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceViewServerResponse, error)

	// GetTokenWithBodyWithResponse request with any body
	GetTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokenServerResponse, error)

	GetTokenWithFormdataBodyWithResponse(ctx context.Context, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokenServerResponse, error)

	// RenameTableWithBodyWithResponse request with any body
	RenameTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameTableServerResponse, error)

	RenameTableWithResponse(ctx context.Context, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameTableServerResponse, error)

	// CommitTransactionWithBodyWithResponse request with any body
	CommitTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionServerResponse, error)

	CommitTransactionWithResponse(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionServerResponse, error)

	// RenameViewWithBodyWithResponse request with any body
	RenameViewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameViewServerResponse, error)

	RenameViewWithResponse(ctx context.Context, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameViewServerResponse, error)
}

type GetConfigServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogConfig
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *GetConfigServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *GetConfigServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *GetConfigServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *GetConfigServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNamespacesServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNamespacesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *ListNamespacesServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ListNamespacesServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ListNamespacesServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ListNamespacesServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNamespaceServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNamespaceResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON406      *UnsupportedOperationResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *CreateNamespaceServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON406,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *CreateNamespaceServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *CreateNamespaceServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *CreateNamespaceServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropNamespaceServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *DropNamespaceServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *DropNamespaceServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *DropNamespaceServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *DropNamespaceServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadNamespaceMetadataServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNamespaceResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *LoadNamespaceMetadataServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *LoadNamespaceMetadataServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *LoadNamespaceMetadataServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *LoadNamespaceMetadataServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespaceExistsServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *NamespaceExistsServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *NamespaceExistsServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *NamespaceExistsServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *NamespaceExistsServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePropertiesServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNamespacePropertiesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON406      *UnsupportedOperationResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON422      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *UpdatePropertiesServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON406,
		r.JSON419,
		r.JSON422,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *UpdatePropertiesServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *UpdatePropertiesServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *UpdatePropertiesServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *RegisterTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *RegisterTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *RegisterTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *RegisterTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTablesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *ListTablesServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ListTablesServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ListTablesServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ListTablesServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *CreateTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *CreateTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *CreateTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *CreateTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *DropTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *DropTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *DropTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *DropTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *LoadTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *LoadTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *LoadTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *LoadTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableExistsServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *TableExistsServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *TableExistsServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *TableExistsServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *TableExistsServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *IcebergErrorResponse
	JSON502      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON504      *IcebergErrorResponse
	JSON5XX      *IcebergErrorResponse
}

// Error returns the API response error if any.
func (r *UpdateTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON500,
		r.JSON502,
		r.JSON503,
		r.JSON504,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *UpdateTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *UpdateTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *UpdateTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportMetricsServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *ReportMetricsServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ReportMetricsServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ReportMetricsServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ReportMetricsServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListViewsServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTablesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *ListViewsServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ListViewsServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ListViewsServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ListViewsServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *CreateViewServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *CreateViewServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *CreateViewServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *CreateViewServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropViewServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *DropViewServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *DropViewServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *DropViewServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *DropViewServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadViewServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *LoadViewServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *LoadViewServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *LoadViewServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *LoadViewServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViewExistsServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *ViewExistsServerResponse) Error() error {
	possibilities := []any{
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ViewExistsServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ViewExistsServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ViewExistsServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceViewServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *ErrorModel
	JSON502      *ErrorModel
	JSON503      *ServiceUnavailableResponse
	JSON504      *ErrorModel
	JSON5XX      *ErrorModel
}

// Error returns the API response error if any.
func (r *ReplaceViewServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON500,
		r.JSON502,
		r.JSON503,
		r.JSON504,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *ReplaceViewServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *ReplaceViewServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *ReplaceViewServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthTokenResponse
	JSON400      *OAuthErrorResponse
	JSON401      *OAuthErrorResponse
	JSON5XX      *OAuthErrorResponse
}

// Error returns the API response error if any.
func (r *GetTokenServerResponse) Error() error {
	possibilities := []any{
		r.JSON200,
		r.JSON400,
		r.JSON401,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *GetTokenServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *GetTokenServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *GetTokenServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameTableServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON406      *UnsupportedOperationResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *RenameTableServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON406,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *RenameTableServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *RenameTableServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *RenameTableServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *IcebergErrorResponse
	JSON502      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON504      *IcebergErrorResponse
	JSON5XX      *IcebergErrorResponse
}

// Error returns the API response error if any.
func (r *CommitTransactionServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON409,
		r.JSON419,
		r.JSON500,
		r.JSON502,
		r.JSON503,
		r.JSON504,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *CommitTransactionServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *CommitTransactionServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *CommitTransactionServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameViewServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON406      *UnsupportedOperationResponse
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Error returns the API response error if any.
func (r *RenameViewServerResponse) Error() error {
	possibilities := []any{
		r.JSON400,
		r.JSON401,
		r.JSON403,
		r.JSON404,
		r.JSON406,
		r.JSON409,
		r.JSON419,
		r.JSON503,
		r.JSON5XX,
	}

	for _, v := range possibilities {
		if v == nil {
			continue
		}

		if err, ok := v.(*ErrorModel); ok && err != nil {
			return err
		}

		if err, ok := v.(*IcebergErrorResponse); ok && err != nil {
			return &err.Error
		}
	}

	return nil
}

// RawBody returns the bytes of the response body.
func (r *RenameViewServerResponse) RawBody() []byte {
	return r.Body
}

// Status returns HTTPResponse.Status
func (r *RenameViewServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r *RenameViewServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConfigWithResponse request returning *GetConfigServerResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigServerResponse, error) {
	rsp, err := c.GetConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigServerResponse(rsp)
}

// ListNamespacesWithResponse request returning *ListNamespacesServerResponse
func (c *ClientWithResponses) ListNamespacesWithResponse(ctx context.Context, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*ListNamespacesServerResponse, error) {
	rsp, err := c.ListNamespaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNamespacesServerResponse(rsp)
}

// CreateNamespaceWithBodyWithResponse request with arbitrary body returning *CreateNamespaceServerResponse
func (c *ClientWithResponses) CreateNamespaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceServerResponse, error) {
	rsp, err := c.CreateNamespaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceServerResponse(rsp)
}

func (c *ClientWithResponses) CreateNamespaceWithResponse(ctx context.Context, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceServerResponse, error) {
	rsp, err := c.CreateNamespace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceServerResponse(rsp)
}

// DropNamespaceWithResponse request returning *DropNamespaceServerResponse
func (c *ClientWithResponses) DropNamespaceWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*DropNamespaceServerResponse, error) {
	rsp, err := c.DropNamespace(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropNamespaceServerResponse(rsp)
}

// LoadNamespaceMetadataWithResponse request returning *LoadNamespaceMetadataServerResponse
func (c *ClientWithResponses) LoadNamespaceMetadataWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*LoadNamespaceMetadataServerResponse, error) {
	rsp, err := c.LoadNamespaceMetadata(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadNamespaceMetadataServerResponse(rsp)
}

// NamespaceExistsWithResponse request returning *NamespaceExistsServerResponse
func (c *ClientWithResponses) NamespaceExistsWithResponse(ctx context.Context, namespace Namespace, reqEditors ...RequestEditorFn) (*NamespaceExistsServerResponse, error) {
	rsp, err := c.NamespaceExists(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceExistsServerResponse(rsp)
}

// UpdatePropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePropertiesServerResponse
func (c *ClientWithResponses) UpdatePropertiesWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesServerResponse, error) {
	rsp, err := c.UpdatePropertiesWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesServerResponse(rsp)
}

func (c *ClientWithResponses) UpdatePropertiesWithResponse(ctx context.Context, namespace Namespace, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePropertiesServerResponse, error) {
	rsp, err := c.UpdateProperties(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesServerResponse(rsp)
}

// RegisterTableWithBodyWithResponse request with arbitrary body returning *RegisterTableServerResponse
func (c *ClientWithResponses) RegisterTableWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTableServerResponse, error) {
	rsp, err := c.RegisterTableWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTableServerResponse(rsp)
}

func (c *ClientWithResponses) RegisterTableWithResponse(ctx context.Context, namespace Namespace, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTableServerResponse, error) {
	rsp, err := c.RegisterTable(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTableServerResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesServerResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, namespace Namespace, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesServerResponse, error) {
	rsp, err := c.ListTables(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesServerResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableServerResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, namespace Namespace, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableServerResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, namespace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableServerResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, namespace Namespace, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableServerResponse, error) {
	rsp, err := c.CreateTable(ctx, namespace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableServerResponse(rsp)
}

// DropTableWithResponse request returning *DropTableServerResponse
func (c *ClientWithResponses) DropTableWithResponse(ctx context.Context, namespace Namespace, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*DropTableServerResponse, error) {
	rsp, err := c.DropTable(ctx, namespace, table, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropTableServerResponse(rsp)
}

// LoadTableWithResponse request returning *LoadTableServerResponse
func (c *ClientWithResponses) LoadTableWithResponse(ctx context.Context, namespace Namespace, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*LoadTableServerResponse, error) {
	rsp, err := c.LoadTable(ctx, namespace, table, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadTableServerResponse(rsp)
}

// TableExistsWithResponse request returning *TableExistsServerResponse
func (c *ClientWithResponses) TableExistsWithResponse(ctx context.Context, namespace Namespace, table Table, reqEditors ...RequestEditorFn) (*TableExistsServerResponse, error) {
	rsp, err := c.TableExists(ctx, namespace, table, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableExistsServerResponse(rsp)
}

// UpdateTableWithBodyWithResponse request with arbitrary body returning *UpdateTableServerResponse
func (c *ClientWithResponses) UpdateTableWithBodyWithResponse(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableServerResponse, error) {
	rsp, err := c.UpdateTableWithBody(ctx, namespace, table, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableServerResponse(rsp)
}

func (c *ClientWithResponses) UpdateTableWithResponse(ctx context.Context, namespace Namespace, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableServerResponse, error) {
	rsp, err := c.UpdateTable(ctx, namespace, table, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableServerResponse(rsp)
}

// ReportMetricsWithBodyWithResponse request with arbitrary body returning *ReportMetricsServerResponse
func (c *ClientWithResponses) ReportMetricsWithBodyWithResponse(ctx context.Context, namespace Namespace, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportMetricsServerResponse, error) {
	rsp, err := c.ReportMetricsWithBody(ctx, namespace, table, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportMetricsServerResponse(rsp)
}

func (c *ClientWithResponses) ReportMetricsWithResponse(ctx context.Context, namespace Namespace, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportMetricsServerResponse, error) {
	rsp, err := c.ReportMetrics(ctx, namespace, table, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportMetricsServerResponse(rsp)
}

// ListViewsWithResponse request returning *ListViewsServerResponse
func (c *ClientWithResponses) ListViewsWithResponse(ctx context.Context, namespace Namespace, params *ListViewsParams, reqEditors ...RequestEditorFn) (*ListViewsServerResponse, error) {
	rsp, err := c.ListViews(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListViewsServerResponse(rsp)
}

// CreateViewWithBodyWithResponse request with arbitrary body returning *CreateViewServerResponse
func (c *ClientWithResponses) CreateViewWithBodyWithResponse(ctx context.Context, namespace Namespace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewServerResponse, error) {
	rsp, err := c.CreateViewWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewServerResponse(rsp)
}

func (c *ClientWithResponses) CreateViewWithResponse(ctx context.Context, namespace Namespace, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateViewServerResponse, error) {
	rsp, err := c.CreateView(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewServerResponse(rsp)
}

// DropViewWithResponse request returning *DropViewServerResponse
func (c *ClientWithResponses) DropViewWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*DropViewServerResponse, error) {
	rsp, err := c.DropView(ctx, namespace, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropViewServerResponse(rsp)
}

// LoadViewWithResponse request returning *LoadViewServerResponse
func (c *ClientWithResponses) LoadViewWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*LoadViewServerResponse, error) {
	rsp, err := c.LoadView(ctx, namespace, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadViewServerResponse(rsp)
}

// ViewExistsWithResponse request returning *ViewExistsServerResponse
func (c *ClientWithResponses) ViewExistsWithResponse(ctx context.Context, namespace Namespace, view View, reqEditors ...RequestEditorFn) (*ViewExistsServerResponse, error) {
	rsp, err := c.ViewExists(ctx, namespace, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewExistsServerResponse(rsp)
}

// ReplaceViewWithBodyWithResponse request with arbitrary body returning *ReplaceViewServerResponse
func (c *ClientWithResponses) ReplaceViewWithBodyWithResponse(ctx context.Context, namespace Namespace, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceViewServerResponse, error) {
	rsp, err := c.ReplaceViewWithBody(ctx, namespace, view, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceViewServerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceViewWithResponse(ctx context.Context, namespace Namespace, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceViewServerResponse, error) {
	rsp, err := c.ReplaceView(ctx, namespace, view, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceViewServerResponse(rsp)
}

// GetTokenWithBodyWithResponse request with arbitrary body returning *GetTokenServerResponse
func (c *ClientWithResponses) GetTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokenServerResponse, error) {
	rsp, err := c.GetTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenServerResponse(rsp)
}

func (c *ClientWithResponses) GetTokenWithFormdataBodyWithResponse(ctx context.Context, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokenServerResponse, error) {
	rsp, err := c.GetTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenServerResponse(rsp)
}

// RenameTableWithBodyWithResponse request with arbitrary body returning *RenameTableServerResponse
func (c *ClientWithResponses) RenameTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameTableServerResponse, error) {
	rsp, err := c.RenameTableWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameTableServerResponse(rsp)
}

func (c *ClientWithResponses) RenameTableWithResponse(ctx context.Context, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameTableServerResponse, error) {
	rsp, err := c.RenameTable(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameTableServerResponse(rsp)
}

// CommitTransactionWithBodyWithResponse request with arbitrary body returning *CommitTransactionServerResponse
func (c *ClientWithResponses) CommitTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionServerResponse, error) {
	rsp, err := c.CommitTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionServerResponse(rsp)
}

func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionServerResponse, error) {
	rsp, err := c.CommitTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionServerResponse(rsp)
}

// RenameViewWithBodyWithResponse request with arbitrary body returning *RenameViewServerResponse
func (c *ClientWithResponses) RenameViewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameViewServerResponse, error) {
	rsp, err := c.RenameViewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameViewServerResponse(rsp)
}

func (c *ClientWithResponses) RenameViewWithResponse(ctx context.Context, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameViewServerResponse, error) {
	rsp, err := c.RenameView(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameViewServerResponse(rsp)
}

// ParseGetConfigServerResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigServerResponse(rsp *http.Response) (*GetConfigServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListNamespacesServerResponse parses an HTTP response from a ListNamespacesWithResponse call
func ParseListNamespacesServerResponse(rsp *http.Response) (*ListNamespacesServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNamespacesServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNamespacesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateNamespaceServerResponse parses an HTTP response from a CreateNamespaceWithResponse call
func ParseCreateNamespaceServerResponse(rsp *http.Response) (*CreateNamespaceServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNamespaceServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropNamespaceServerResponse parses an HTTP response from a DropNamespaceWithResponse call
func ParseDropNamespaceServerResponse(rsp *http.Response) (*DropNamespaceServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropNamespaceServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadNamespaceMetadataServerResponse parses an HTTP response from a LoadNamespaceMetadataWithResponse call
func ParseLoadNamespaceMetadataServerResponse(rsp *http.Response) (*LoadNamespaceMetadataServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadNamespaceMetadataServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseNamespaceExistsServerResponse parses an HTTP response from a NamespaceExistsWithResponse call
func ParseNamespaceExistsServerResponse(rsp *http.Response) (*NamespaceExistsServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespaceExistsServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdatePropertiesServerResponse parses an HTTP response from a UpdatePropertiesWithResponse call
func ParseUpdatePropertiesServerResponse(rsp *http.Response) (*UpdatePropertiesServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePropertiesServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNamespacePropertiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRegisterTableServerResponse parses an HTTP response from a RegisterTableWithResponse call
func ParseRegisterTableServerResponse(rsp *http.Response) (*RegisterTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListTablesServerResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesServerResponse(rsp *http.Response) (*ListTablesServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateTableServerResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableServerResponse(rsp *http.Response) (*CreateTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropTableServerResponse parses an HTTP response from a DropTableWithResponse call
func ParseDropTableServerResponse(rsp *http.Response) (*DropTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadTableServerResponse parses an HTTP response from a LoadTableWithResponse call
func ParseLoadTableServerResponse(rsp *http.Response) (*LoadTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTableExistsServerResponse parses an HTTP response from a TableExistsWithResponse call
func ParseTableExistsServerResponse(rsp *http.Response) (*TableExistsServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableExistsServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdateTableServerResponse parses an HTTP response from a UpdateTableWithResponse call
func ParseUpdateTableServerResponse(rsp *http.Response) (*UpdateTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseReportMetricsServerResponse parses an HTTP response from a ReportMetricsWithResponse call
func ParseReportMetricsServerResponse(rsp *http.Response) (*ReportMetricsServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportMetricsServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListViewsServerResponse parses an HTTP response from a ListViewsWithResponse call
func ParseListViewsServerResponse(rsp *http.Response) (*ListViewsServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListViewsServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateViewServerResponse parses an HTTP response from a CreateViewWithResponse call
func ParseCreateViewServerResponse(rsp *http.Response) (*CreateViewServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropViewServerResponse parses an HTTP response from a DropViewWithResponse call
func ParseDropViewServerResponse(rsp *http.Response) (*DropViewServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropViewServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadViewServerResponse parses an HTTP response from a LoadViewWithResponse call
func ParseLoadViewServerResponse(rsp *http.Response) (*LoadViewServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadViewServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseViewExistsServerResponse parses an HTTP response from a ViewExistsWithResponse call
func ParseViewExistsServerResponse(rsp *http.Response) (*ViewExistsServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViewExistsServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseReplaceViewServerResponse parses an HTTP response from a ReplaceViewWithResponse call
func ParseReplaceViewServerResponse(rsp *http.Response) (*ReplaceViewServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceViewServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTokenServerResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenServerResponse(rsp *http.Response) (*GetTokenServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRenameTableServerResponse parses an HTTP response from a RenameTableWithResponse call
func ParseRenameTableServerResponse(rsp *http.Response) (*RenameTableServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameTableServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCommitTransactionServerResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionServerResponse(rsp *http.Response) (*CommitTransactionServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRenameViewServerResponse parses an HTTP response from a RenameViewWithResponse call
func ParseRenameViewServerResponse(rsp *http.Response) (*RenameViewServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameViewServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
